### 1月7日凌晨 2:15 更新记录

将代码修改接口进行性能测试，并通过52条指令的全部64条测试点。

**错误1**：代码在初次仿真的时候直接pass，但是观察控制台中没有任何输出，观察波形图全是 Z 和 X 波形。

**修改方法**：在进行仿真的时候检查我们顶层文件的接口是否匹配，发现接口没有匹配。匹配接口后可以正常进行性能测试。

**错误2**：移位运算的时候高三位始终与标准答案不一致。

**修改方法**：在检查移位运算指令时发现理解指令出现了偏差。移位指令移动的位数只与低 5 位相关而不考虑高位情况。修改 ALU 相关代码使得移动位数只关注低 5 位。

**错误3**：在分支跳转指令之后紧接除法指令时，因为除法指令的执行阶段需要的周期位 32 个周期。

**修改方法**：此问题属于冒险问题，主要修改的文件是冒险模块。

在冒险模块中的 flushE 阶段需要判断当前是否在进行除法运算。如果当前没有在除法阶段而进行分支跳转指令的话，在 D->E 锁存器进入的是一个错误的指令，需要清除。但是如果分支跳转的后一条指令是除法运算指令，因为除法指令的运算时间非常长，这个时候就不能刷新 D->E 锁存器防止正常的除法指令运算时被刷新掉。

在 flushM 阶段如果当前正在进行除法运算的时候，需要对 M->W 的锁存器进行刷新，以防止除法模块运算过程中产生不必要的信号干扰正常指令。

**冒险模块代码修改**

1. 针对除法运算相关的 stall 和 flush 的判定逻辑进行修改



### 1月6日 18:16 更新记录

主要将分支跳转部分代码加入数据通路中，在数据通路、冒险等模块中更新了一系列代码。其中分支跳转默认执行延迟槽和默认不跳转，只有当跳转时才会 flush F、D、E 阶段的全部数据。

**错误 1**：分支link指令的运算结果与理想结果不符。

**修改方法**：在数据通路中将运算结果和pc+8地址连接了同一个选择器，这个选择器将运算结果过滤掉了。将运算结果新增加一条线即可解决此bug。

**错误 2**：jar和jalr指令无法正常写入对应的寄存器堆。

**修改方法**：控制器和数据通路新增加一个jr信号来控制pc+8地址写入寄存器。

**错误 3**：某些分支指令无法正常运行。

**解决办法**：分支跳转指令的 op 字段相同，需要结合其他字段进行判断。

**数据通路部分**

1. 新增 pc+8 地址的计算组件
2. 新增多个选择器和控制信号，将 pc+8、pc+4 和 是否等于零的结果向后推送，写入对应的寄存器中。

**冒险模块部分**

1. 当分支跳转在 M 阶段时 flush F、D、E 阶段的全部数据。（相关的 flush 信号全部置1）。

**Controller 和 ALU 部分**

1. 增加分支跳转相对应的全部译码信号和处理代码。



### 1月6日 10:14 更新记录

**错误修订**：SB和SH无法正确将数据写进存储器的bug

**修改方法**：将写入的数据扩展复制到字的每一个部分



### 1月6日 2:09 更新记录

主要将branch和jump位置从D阶段跳转改为M阶段跳转

**datapath部分**

1. 将原先D阶段的选择器和比较器注释掉
2. 在alu中增加zero的计算
3. 在datapath中新增zero和overflow控制信号
4. 新增pcjumpD = {pcplus4D[31:28], instrD[25:0], 2'b00};
5. 新增pcsrcM = branchM & zeroM;
6. 将branch、jump、pcbranch、pcjump、pcplus4、zero和overflow推至M阶段

**hazard部分**

1. 新增了控制信号jump_branchM = jumpM | pcsrcM;
2. 取代了之前的stall和flush信号的判断条件



### 1月5日 21:00 更新记录

**错误：**LHU指令无法正确计算相应的地址

**修订：**地址应该乘4再去访问存储器，alu少打了LHU字符

添加了访存指令

**datapath部分**

1. 新增了输出部分，将四位字节写使能信号作为输出，并添加每一阶段的锁存器保存此结果。字节写使能信号由解码出的alucontrol字段进行赋值。
2. 将存储器中读出的值进行处理，单独提取出相关的有符号/无符号的字节、半字

**Hazard部分**

1. 添加相关的流水线暂停部分（WAR冒险）

**MIPS部分**

1. 将四位字节写使能信号作为输出

**mycpu_top部分**

1. 将四位字节写使能信号作为输出

**top部分**

1. 将四位字节写使能信号输入到data存储器中，替换掉原来的4位全1

**maindec和alu部分**

1. 添加了LB、LBU、LH、LHU、SH和SB指令相关处理代码



### 1月5日 13:03 更新记录

完成了除法器不能正常停止流水线的错误

将hazard中的stall信号补全，在datapath中修订相关的stall信号连线。因为在stall状态下，流水线会将暂停的流水级锁存器内容进行情况，故在datapath中建立一个reg变量存储stall后的相关值。在流水下重新启动时读取相对应的数据。



### 1月5日 2:55 更新记录

**错误**：除法无法正常停止流水线

**新增模块 div.v**

更新了defines.vh文件，在其中包含除法器相关的宏定义

**alu部分**

1. 新增加clk, rst, div_stall 信号
2. 导入除法器模块
3. 新增了一个always模块，在其中更新除法器相关控制信号

**Datapath部分**

1. 将alu和冒险部分的控制信号更新
2. 将执行阶段的D除法器全部更新为flopenrc





### 1月4日 23:04 更新记录

错误：仿真时，寄存器堆读出的数据为未定型，这直接导致了后续指令的错误
解决：controller中添加了新的信号，但是control的长度没有更新

**controller部分**

1. 新增加信号write_hiloD表示是否写hilo

**maindec部分**

1. 新增加write_hilo信号
2. 添加 MTHI、MTLO、MFHI和MFLO的译码

**hazard部分**

1. 增加输入输出   input wire write_hiloM,  output wire forward_hilo_E,
2.   assign forward_hilo_E = write_hiloM;

**datapath部分**

1. 调用hilo_reg，并增加forword_hilo_mux来选择hilo_reg的输入信号（实现数据前推功能）

**hilo_reg部分**

1. 新建了hilo_reg.v文件
2. 此文件在datapath中被调用



### 1月4日 18:38 更新记录

将regfile.v修改回了实验4的版本

### 1月4日18:01更新记录：

**错误**

1. 仿真的结果，全部位移指令输出全为零
2. 仿真的SRA和SRAV两条指令高位补0（算数右移应该补1）

**ALU部分**

1. 将位移指令的SRA和SRAV修改为有符号扩展

**maindec.v部分**

1. 将位移指令移动到R-type下判断

结果：修订可以通过位移指令的仿真测试。



### 1月4日15：00更新记录：

**ALU部分**：新增了偏移量instr[10:6]作为输入offset，处理逻辑移位运算；

**数据通路部分**：增加了偏移量offsetD与offsetE;



### 1月4号凌晨更新记录：

**数据通路部分**

1. 取消了aludec.v，将此代码的功能集成到来maindec.v中。controller.v中删除了aludec.v的相关代码。
2. 我们的aluop从原先的三位扩展到了八位，所以修改了三个阶段的锁存器参数，从原先的8位增加到了14位，并增加参数FLOP_WIDTH。
3. 在floprc增加sign_extdD和sign_extdE信号；
4. 在处理无符号扩展时，需要将原代码中的signext中有符号扩展部分新增加无符号扩展代码。
5. 此项修改需要调整数据通路结构：
   1. Controller 新增加1bit信号（sign_extd）来判断此指令是否需要有符号扩展（1表示有符号，0表示无符号）。sign_extd信号推向下一级锁存器；（对应代码中的变量是sign_extdE, sign_extdD）；
   2. signext 新增加一条无符号扩展输出，译码阶段同时输出有符号和无符号结果，两个结果都会推向下一级锁存器；
   3. 在执行阶段时，更具sign_extd选择上一阶段的锁存器选择有符号/无符号结果。

